#!/usr/bin/env node

/**
 * UIËá™Âä®ÂåñÊµãËØïËÑöÊú¨
 * ÊµãËØïËÅäÂ§©ÁïåÈù¢ÁöÑÂÖ≥ÈîÆÁî®Êà∑‰∫§‰∫íÂíåÊÄßËÉΩ
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class UIAutomationTester {
  constructor() {
    this.projectRoot = process.cwd();
    this.testResultsFile = path.join(this.projectRoot, 'ui-test-results.json');
    this.devServerUrl = 'http://localhost:5173';
  }

  async runFullTestSuite() {
    console.log('üß™ ÂºÄÂßãUIËá™Âä®ÂåñÊµãËØïÂ•ó‰ª∂...');
    const startTime = Date.now();
    
    const testResults = {
      timestamp: new Date().toISOString(),
      tests: {
        componentLoad: await this.testComponentLoading(),
        chatInteraction: await this.testChatInteraction(),
        performanceMetrics: await this.testPerformanceMetrics(),
        accessibility: await this.testAccessibility(),
        responsiveDesign: await this.testResponsiveDesign()
      }
    };

    const endTime = Date.now();
    testResults.totalTestTime = endTime - startTime;
    
    await this.saveTestResults(testResults);
    this.generateTestReport(testResults);
    
    return testResults;
  }

  async testComponentLoading() {
    console.log('üîç ÊµãËØïÁªÑ‰ª∂Âä†ËΩΩÊÄßËÉΩ...');
    try {
      // Ê£ÄÊü•ÂÖ≥ÈîÆÊñá‰ª∂Â≠òÂú®ÊÄß
      const criticalFiles = [
        'src/components/chat/ChatHistory.tsx',
        'src/components/chat/ChatInput.tsx',
        'src/components/chat/ChatMessage.tsx',
        'src/components/chat/VirtualizedMessageList.tsx'
      ];

      const loadingResults = [];
      
      for (const filePath of criticalFiles) {
        const fullPath = path.join(this.projectRoot, filePath);
        const startTime = Date.now();
        
        if (fs.existsSync(fullPath)) {
          const content = fs.readFileSync(fullPath, 'utf8');
          const loadTime = Date.now() - startTime;
          
          // ÂàÜÊûêÁªÑ‰ª∂Â§çÊùÇÂ∫¶
          const complexity = this.analyzeComponentComplexity(content);
          
          loadingResults.push({
            file: filePath,
            status: 'PASS',
            loadTime,
            complexity,
            size: content.length
          });
        } else {
          loadingResults.push({
            file: filePath,
            status: 'FAIL',
            error: 'File not found'
          });
        }
      }

      const avgLoadTime = loadingResults.reduce((sum, result) => 
        sum + (result.loadTime || 0), 0) / loadingResults.length;
      
      return {
        status: avgLoadTime < 100 ? 'PASS' : 'WARN',
        avgLoadTime,
        results: loadingResults,
        recommendation: this.getLoadingRecommendation(avgLoadTime)
      };
      
    } catch (error) {
      return {
        status: 'ERROR',
        error: error.message
      };
    }
  }

  async testChatInteraction() {
    console.log('üí¨ ÊµãËØïËÅäÂ§©‰∫§‰∫íÂäüËÉΩ...');
    try {
      // Ê£ÄÊü•‰∫§‰∫íÁõ∏ÂÖ≥ÁöÑhooksÂíåÂäüËÉΩ
      const chatHookPath = path.join(this.projectRoot, 'src/hooks/useDifyChat.ts');
      
      if (!fs.existsSync(chatHookPath)) {
        return {
          status: 'FAIL',
          error: 'Chat hook not found'
        };
      }

      const hookContent = fs.readFileSync(chatHookPath, 'utf8');
      
      // Ê£ÄÊü•ÂÖ≥ÈîÆÂäüËÉΩ
      const features = {
        sendMessage: hookContent.includes('sendMessage'),
        clearMessages: hookContent.includes('clearMessages'),
        retryMessage: hookContent.includes('retry') || hookContent.includes('resend'),
        messageHistory: hookContent.includes('messages'),
        streaming: hookContent.includes('streaming') || hookContent.includes('isStreaming'),
        errorHandling: hookContent.includes('error') || hookContent.includes('Error')
      };

      const featureScore = Object.values(features).filter(Boolean).length;
      const totalFeatures = Object.keys(features).length;
      const score = (featureScore / totalFeatures) * 100;

      return {
        status: score >= 80 ? 'PASS' : 'WARN',
        score,
        features,
        recommendation: this.getChatInteractionRecommendation(features, score)
      };

    } catch (error) {
      return {
        status: 'ERROR',
        error: error.message
      };
    }
  }

  async testPerformanceMetrics() {
    console.log('üìä ÊµãËØïÊÄßËÉΩÊåáÊ†á...');
    try {
      // Ê£ÄÊü•ÊòØÂê¶ÊúâÊÄßËÉΩ‰ºòÂåñ
      const chatHistoryPath = path.join(this.projectRoot, 'src/components/chat/ChatHistory.tsx');
      const content = fs.readFileSync(chatHistoryPath, 'utf8');
      
      const optimizations = {
        useMemo: (content.match(/useMemo/g) || []).length,
        useCallback: (content.match(/useCallback/g) || []).length,
        memo: content.includes('memo('),
        lazyLoading: content.includes('lazy') || content.includes('Suspense'),
        virtualization: content.includes('VirtualizedMessageList') || content.includes('FixedSizeList')
      };

      // Ê£ÄÊü•BundleÂ§ßÂ∞è
      const distPath = path.join(this.projectRoot, 'dist');
      let bundleSize = 0;
      
      if (fs.existsSync(distPath)) {
        bundleSize = this.getDirectorySize(distPath);
      }

      const performanceScore = this.calculatePerformanceScore(optimizations, bundleSize);

      return {
        status: performanceScore >= 75 ? 'PASS' : 'WARN',
        score: performanceScore,
        optimizations,
        bundleSize,
        recommendation: this.getPerformanceRecommendation(optimizations, performanceScore)
      };

    } catch (error) {
      return {
        status: 'ERROR',
        error: error.message
      };
    }
  }

  async testAccessibility() {
    console.log('‚ôø ÊµãËØïÂèØËÆøÈóÆÊÄß...');
    try {
      const components = [
        'src/components/chat/ChatHistory.tsx',
        'src/components/chat/ChatInput.tsx',
        'src/components/chat/ChatMessage.tsx'
      ];

      const accessibilityResults = [];

      for (const componentPath of components) {
        const fullPath = path.join(this.projectRoot, componentPath);
        if (fs.existsSync(fullPath)) {
          const content = fs.readFileSync(fullPath, 'utf8');
          
          const accessibility = {
            ariaLabels: (content.match(/aria-label/g) || []).length,
            ariaDescribedby: (content.match(/aria-describedby/g) || []).length,
            keyboardNav: content.includes('onKeyDown') || content.includes('tabIndex'),
            semanticHTML: content.includes('<button') || content.includes('<input') || content.includes('<textarea'),
            altText: content.includes('alt=')
          };

          const score = this.calculateAccessibilityScore(accessibility);
          
          accessibilityResults.push({
            component: componentPath,
            score,
            accessibility
          });
        }
      }

      const avgScore = accessibilityResults.reduce((sum, result) => sum + result.score, 0) / accessibilityResults.length;

      return {
        status: avgScore >= 70 ? 'PASS' : 'WARN',
        avgScore,
        results: accessibilityResults,
        recommendation: this.getAccessibilityRecommendation(avgScore)
      };

    } catch (error) {
      return {
        status: 'ERROR',
        error: error.message
      };
    }
  }

  async testResponsiveDesign() {
    console.log('üì± ÊµãËØïÂìçÂ∫îÂºèËÆæËÆ°...');
    try {
      // Ê£ÄÊü•CSSÂíåÂìçÂ∫îÂºèÁ±ª
      const styleFiles = [
        'src/index.css',
        'tailwind.config.ts'
      ];

      const responsiveFeatures = {
        flexbox: false,
        grid: false,
        mediaQueries: false,
        tailwindResponsive: false,
        mobileFirst: false
      };

      for (const styleFile of styleFiles) {
        const fullPath = path.join(this.projectRoot, styleFile);
        if (fs.existsSync(fullPath)) {
          const content = fs.readFileSync(fullPath, 'utf8');
          
          if (content.includes('flex') || content.includes('grid')) {
            responsiveFeatures.flexbox = true;
          }
          if (content.includes('grid')) {
            responsiveFeatures.grid = true;
          }
          if (content.includes('@media') || content.includes('sm:') || content.includes('md:')) {
            responsiveFeatures.mediaQueries = true;
            responsiveFeatures.tailwindResponsive = true;
          }
        }
      }

      // Ê£ÄÊü•ÁªÑ‰ª∂‰∏≠ÁöÑÂìçÂ∫îÂºèÁ±ª
      const chatComponents = [
        'src/components/chat/ChatHistory.tsx',
        'src/components/chat/ChatInput.tsx'
      ];

      for (const componentPath of chatComponents) {
        const fullPath = path.join(this.projectRoot, componentPath);
        if (fs.existsSync(fullPath)) {
          const content = fs.readFileSync(fullPath, 'utf8');
          if (content.includes('sm:') || content.includes('md:') || content.includes('lg:')) {
            responsiveFeatures.tailwindResponsive = true;
            responsiveFeatures.mobileFirst = true;
          }
        }
      }

      const responsiveScore = this.calculateResponsiveScore(responsiveFeatures);

      return {
        status: responsiveScore >= 60 ? 'PASS' : 'WARN',
        score: responsiveScore,
        features: responsiveFeatures,
        recommendation: this.getResponsiveRecommendation(responsiveFeatures, responsiveScore)
      };

    } catch (error) {
      return {
        status: 'ERROR',
        error: error.message
      };
    }
  }

  analyzeComponentComplexity(content) {
    const hooks = (content.match(/use\w+/g) || []).length;
    const conditions = (content.match(/if|switch|\?/g) || []).length;
    const loops = (content.match(/map|forEach|for/g) || []).length;
    const components = (content.match(/<[A-Z]\w+/g) || []).length;
    
    return {
      hooks,
      conditions,
      loops,
      components,
      complexity: hooks + conditions + loops + components
    };
  }

  getDirectorySize(dirPath) {
    let totalSize = 0;
    
    const files = fs.readdirSync(dirPath);
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      const stats = fs.statSync(filePath);
      
      if (stats.isDirectory()) {
        totalSize += this.getDirectorySize(filePath);
      } else {
        totalSize += stats.size;
      }
    }
    
    return totalSize;
  }

  calculatePerformanceScore(optimizations, bundleSize) {
    let score = 0;
    
    if (optimizations.useMemo > 0) score += 20;
    if (optimizations.useCallback > 0) score += 20;
    if (optimizations.memo) score += 20;
    if (optimizations.virtualization) score += 25;
    if (optimizations.lazyLoading) score += 15;
    if (bundleSize < 5 * 1024 * 1024) score += 0; // No penalty for reasonable size
    
    return Math.min(score, 100);
  }

  calculateAccessibilityScore(accessibility) {
    let score = 0;
    
    if (accessibility.ariaLabels > 0) score += 25;
    if (accessibility.keyboardNav) score += 25;
    if (accessibility.semanticHTML) score += 25;
    if (accessibility.ariaDescribedby > 0) score += 15;
    if (accessibility.altText) score += 10;
    
    return Math.min(score, 100);
  }

  calculateResponsiveScore(features) {
    let score = 0;
    
    if (features.flexbox) score += 20;
    if (features.grid) score += 15;
    if (features.mediaQueries) score += 25;
    if (features.tailwindResponsive) score += 30;
    if (features.mobileFirst) score += 10;
    
    return Math.min(score, 100);
  }

  getLoadingRecommendation(avgLoadTime) {
    if (avgLoadTime < 50) return 'ÁªÑ‰ª∂Âä†ËΩΩÈÄüÂ∫¶‰ºòÁßÄ';
    if (avgLoadTime < 100) return 'ÁªÑ‰ª∂Âä†ËΩΩÈÄüÂ∫¶ËâØÂ•Ω';
    return 'Âª∫ËÆÆ‰ºòÂåñÁªÑ‰ª∂Âä†ËΩΩÊÄßËÉΩ';
  }

  getChatInteractionRecommendation(features, score) {
    const missing = [];
    if (!features.sendMessage) missing.push('ÂèëÈÄÅÊ∂àÊÅØÂäüËÉΩ');
    if (!features.clearMessages) missing.push('Ê∏ÖÁ©∫Ê∂àÊÅØÂäüËÉΩ');
    if (!features.retryMessage) missing.push('ÈáçËØïÊ∂àÊÅØÂäüËÉΩ');
    if (!features.streaming) missing.push('ÊµÅÂºèÂìçÂ∫î');
    if (!features.errorHandling) missing.push('ÈîôËØØÂ§ÑÁêÜ');
    
    return missing.length > 0 ? `Áº∫Â∞ëÂäüËÉΩ: ${missing.join(', ')}` : 'ËÅäÂ§©‰∫§‰∫íÂäüËÉΩÂÆåÊï¥';
  }

  getPerformanceRecommendation(optimizations, score) {
    const suggestions = [];
    if (optimizations.useMemo === 0) suggestions.push('Ê∑ªÂä†useMemo‰ºòÂåñ');
    if (optimizations.useCallback === 0) suggestions.push('Ê∑ªÂä†useCallback‰ºòÂåñ');
    if (!optimizations.memo) suggestions.push('‰ΩøÁî®React.memo');
    if (!optimizations.virtualization) suggestions.push('Ê∑ªÂä†ËôöÊãüÊªöÂä®');
    
    return suggestions.length > 0 ? suggestions.join(', ') : 'ÊÄßËÉΩ‰ºòÂåñËâØÂ•Ω';
  }

  getAccessibilityRecommendation(avgScore) {
    if (avgScore >= 80) return 'ÂèØËÆøÈóÆÊÄß‰ºòÁßÄ';
    if (avgScore >= 60) return 'ÂèØËÆøÈóÆÊÄßËâØÂ•ΩÔºåÂèØÁªßÁª≠ÊîπËøõ';
    return 'ÈúÄË¶ÅÊîπÂñÑÂèØËÆøÈóÆÊÄßÔºåÊ∑ªÂä†Êõ¥Â§öariaÊ†áÁ≠æÂíåËØ≠‰πâÂåñHTML';
  }

  getResponsiveRecommendation(features, score) {
    const suggestions = [];
    if (!features.mediaQueries) suggestions.push('Ê∑ªÂä†Â™í‰ΩìÊü•ËØ¢');
    if (!features.tailwindResponsive) suggestions.push('‰ΩøÁî®TailwindÂìçÂ∫îÂºèÁ±ª');
    if (!features.mobileFirst) suggestions.push('ÈááÁî®ÁßªÂä®Á´Ø‰ºòÂÖàËÆæËÆ°');
    
    return suggestions.length > 0 ? suggestions.join(', ') : 'ÂìçÂ∫îÂºèËÆæËÆ°ËâØÂ•Ω';
  }

  async saveTestResults(results) {
    const existingResults = fs.existsSync(this.testResultsFile) ? 
      JSON.parse(fs.readFileSync(this.testResultsFile, 'utf8')) : { history: [] };
    
    existingResults.latest = results;
    existingResults.history.push(results);
    
    // ‰øùÁïôÊúÄËøë20Êù°ËÆ∞ÂΩï
    if (existingResults.history.length > 20) {
      existingResults.history = existingResults.history.slice(-20);
    }
    
    fs.writeFileSync(this.testResultsFile, JSON.stringify(existingResults, null, 2));
  }

  generateTestReport(results) {
    console.log('\nüß™ UIËá™Âä®ÂåñÊµãËØïÊä•Âëä');
    console.log('='.repeat(50));
    
    Object.entries(results.tests).forEach(([testName, result]) => {
      const statusIcon = result.status === 'PASS' ? '‚úÖ' : 
                        result.status === 'WARN' ? '‚ö†Ô∏è' : '‚ùå';
      console.log(`${statusIcon} ${testName}: ${result.status}`);
      
      if (result.score !== undefined) {
        console.log(`   ËØÑÂàÜ: ${result.score}%`);
      }
      
      if (result.recommendation) {
        console.log(`   Âª∫ËÆÆ: ${result.recommendation}`);
      }
    });
    
    const passedTests = Object.values(results.tests).filter(test => test.status === 'PASS').length;
    const totalTests = Object.keys(results.tests).length;
    const overallScore = (passedTests / totalTests) * 100;
    
    console.log('\nüìä ÊÄª‰ΩìÁªìÊûú');
    console.log(`ÈÄöËøáÁéá: ${overallScore.toFixed(1)}% (${passedTests}/${totalTests})`);
    console.log('‚è±Ô∏è ÊÄªÊµãËØïÊó∂Èó¥:', `${results.totalTestTime}ms`);
    console.log('üìÑ ËØ¶ÁªÜÁªìÊûúÂ∑≤‰øùÂ≠òËá≥:', this.testResultsFile);
  }
}

// CLIÊâßË°å
if (require.main === module) {
  const tester = new UIAutomationTester();
  
  const command = process.argv[2];
  
  if (command === 'run' || !command) {
    tester.runFullTestSuite().then(() => {
      console.log('‚úÖ UIËá™Âä®ÂåñÊµãËØïÂÆåÊàê');
      process.exit(0);
    }).catch(error => {
      console.error('‚ùå UIËá™Âä®ÂåñÊµãËØïÂ§±Ë¥•:', error.message);
      process.exit(1);
    });
  } else {
    console.log(`
üß™ UIËá™Âä®ÂåñÊµãËØïÂ∑•ÂÖ∑

‰ΩøÁî®ÊñπÊ≥ï:
  node scripts/ui-automation-test.cjs run    # ËøêË°åÂÆåÊï¥ÊµãËØïÂ•ó‰ª∂
  node scripts/ui-automation-test.cjs       # ÈªòËÆ§ËøêË°åÊµãËØï

ÊµãËØïÈ°πÁõÆ:
  üîç ÁªÑ‰ª∂Âä†ËΩΩÊÄßËÉΩ
  üí¨ ËÅäÂ§©‰∫§‰∫íÂäüËÉΩ  
  üìä ÊÄßËÉΩÊåáÊ†áÂàÜÊûê
  ‚ôø ÂèØËÆøÈóÆÊÄßÊ£ÄÊü•
  üì± ÂìçÂ∫îÂºèËÆæËÆ°
    `);
  }
}

module.exports = UIAutomationTester;