# 后端积分扣除详细流程

## 📋 完整流程图

```
用户在前端发送消息
    ↓
前端: POST /api/dify/chat-messages { message, userId, conversationId }
    ↓
═══════════════════════════════════════════════════════════════
【后端 server.js - 流式响应模式】
═══════════════════════════════════════════════════════════════

第1步: 接收请求并转发给 Dify API
────────────────────────────────────────────────────────
📍 位置: server.js:1400-1500

app.post('/api/dify/chat-messages', async (req, res) => {
  const { message, userId, conversationId } = req.body;
  
  // 设置SSE响应头
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  
  // 转发请求到 Dify API
  const difyResponse = await fetch('https://api.dify.ai/v1/chat-messages', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${DIFY_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      query: message,
      user: userId,
      conversation_id: conversationId,
      response_mode: 'streaming'  // ← 流式模式
    })
  });
  
  // 继续处理流式响应...
})
    ↓

第2步: 接收并解析 Dify 流式响应
────────────────────────────────────────────────────────
📍 位置: server.js:1600-1800

Dify API 返回 SSE 流式数据：

┌─────────────────────────────────────────────────────┐
│ data: {"event": "message", "answer": "你好"}        │  ← 消息块
│ data: {"event": "message", "answer": "，我是AI"}    │  ← 消息块
│ data: {"event": "message_end", "metadata": {...}}   │  ← 结束事件
└─────────────────────────────────────────────────────┘

后端逐行解析：

const reader = difyResponse.body.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  const chunk = decoder.decode(value);
  const lines = chunk.split('\n');
  
  for (const line of lines) {
    if (line.startsWith('data: ')) {
      const data = line.slice(6);
      
      if (data === '[DONE]') {
        // 流结束，准备计费
        break;
      }
      
      const parsed = JSON.parse(data);
      
      // 转发给前端
      res.write(`data: ${data}\n\n`);
      
      // 收集完整响应数据
      if (parsed.event === 'message') {
        fullAnswer += parsed.answer;  // 累积回答内容
      }
      
      if (parsed.event === 'message_end') {
        // 🎯 关键：保存 metadata，包含 usage 数据
        finalData = {
          answer: fullAnswer,
          conversation_id: parsed.conversation_id,
          message_id: parsed.message_id,
          metadata: parsed.metadata  // ← 包含 usage 信息！
        };
      }
    }
  }
}
    ↓

第3步: 提取 Token 使用数据
────────────────────────────────────────────────────────
📍 位置: server.js:1800-1850

流结束后，finalData 包含完整的 metadata：

finalData = {
  answer: "完整的AI回答内容",
  conversation_id: "b27a9cfb-0c1d-4360-8287-f48df413bdbf",
  message_id: "msg-abc123",
  metadata: {
    usage: {
      prompt_tokens: 3500,        // ← 输入token
      completion_tokens: 663,     // ← 输出token
      total_tokens: 4163,         // ← 总token
      prompt_price: "0.00350",    // ← 输入价格（美元）
      completion_price: "0.00555",// ← 输出价格（美元）
      total_price: "0.00905475",  // ← 总价格（美元）
      currency: "USD",
      latency: 2.5
    }
  }
}

console.log('🔍 [DEBUG] finalData structure for billing:', {
  hasMetadata: !!finalData.metadata,
  hasUsage: !!finalData.metadata?.usage,
  totalTokens: finalData.metadata?.usage?.total_tokens
});
    ↓

第4步: 调用积分扣除函数
────────────────────────────────────────────────────────
📍 位置: server.js:1848

let billingInfo = await handleTokenBilling(
  finalData,           // 包含 usage 数据
  userId,              // '9dee4891-89a6-44ee-8fe8-69097846e97d'
  'WORKFLOW_STREAM'    // 端点类型标识
);
    ↓
    ↓
    ↓ 进入 handleTokenBilling() 函数
    ↓
═══════════════════════════════════════════════════════════════
【handleTokenBilling() 核心计费逻辑】
═══════════════════════════════════════════════════════════════
📍 位置: server.js:673-920

步骤 4.1: 提取 Usage 数据
────────────────────────────────────────────────────────

function handleTokenBilling(responseData, user, endpoint = 'unknown') {
  console.log(`🔍 [BILLING-${endpoint}] Checking responseData structure`);
  
  let totalTokens = null;
  let actualCost = null;
  let usage = null;

  // 检查 metadata.usage (标准位置)
  if (responseData?.metadata?.usage?.total_tokens) {
    usage = responseData.metadata.usage;
    totalTokens = usage.total_tokens;        // 4163
    actualCost = Number(usage.total_price);  // 0.00905475
    
    console.log(`✅ [BILLING-${endpoint}] Found usage in metadata.usage`);
    console.log(`💰 [BILLING-${endpoint}] Multi-node LLM: ${totalTokens} tokens`);
    console.log(`💰 [COST-${endpoint}] Actual cost: $${actualCost.toFixed(6)}`);
  }
  // 其他位置的fallback检查（略）
  
  if (!totalTokens || totalTokens === 0) {
    console.error(`🚨 [BILLING-${endpoint}] No token data found!`);
    return { tokens: 0, success: false };
  }
    ↓

步骤 4.2: 计算扣除积分
────────────────────────────────────────────────────────

  // 🔧 核心公式：美元成本 × 10000 = 积分
  const pointsToDeduct = Math.ceil(actualCost * 10000);
  
  // 示例计算：
  // actualCost = 0.00905475
  // pointsToDeduct = Math.ceil(0.00905475 * 10000)
  //                = Math.ceil(90.5475)
  //                = 91 积分
  
  console.log(`💰 [COST-${endpoint}] Actual cost: $${actualCost.toFixed(6)} = ${pointsToDeduct} points`);
    ↓

步骤 4.3: 验证用户ID
────────────────────────────────────────────────────────

  const userId = getValidUserId(user);
  // userId = '9dee4891-89a6-44ee-8fe8-69097846e97d'
  
  // getValidUserId() 函数检查：
  // 1. 是否是有效的UUID格式
  // 2. 如果不是UUID，尝试提取或生成UUID
    ↓

步骤 4.4: 连接数据库
────────────────────────────────────────────────────────

  const { createClient } = await import('@supabase/supabase-js');
  const supabaseClient = createClient(
    SUPABASE_URL,              // 从环境变量
    SUPABASE_SERVICE_ROLE_KEY  // 从环境变量（管理员权限）
  );
    ↓

步骤 4.5: 查询当前余额
────────────────────────────────────────────────────────

  const { data: userBalance, error: balanceError } = await supabaseClient
    .from('users')
    .select('balance')
    .eq('id', userId)
    .single();
  
  // SQL 等价于：
  // SELECT balance FROM users WHERE id = '9dee4891-89a6-44ee-8fe8-69097846e97d'
  
  if (balanceError) {
    // 用户不存在 → 作为游客处理（不扣数据库积分）
    console.log(`⚠️ [BILLING-${endpoint}] User not found in database: ${userId}`);
    
    // 在内存中记录游客余额
    global.guestBalances.set(userId, 10000 - pointsToDeduct);
    
    return {
      tokens: totalTokens,
      points: pointsToDeduct,
      newBalance: 10000 - pointsToDeduct,
      success: true,
      isGuest: true  // ← 标记为游客
    };
  }
    ↓

步骤 4.6: 计算新余额
────────────────────────────────────────────────────────

  const currentBalance = userBalance.balance;  // 5352
  const newBalance = Math.max(0, currentBalance - pointsToDeduct);
  
  // 示例：
  // currentBalance = 5352
  // pointsToDeduct = 91
  // newBalance = 5352 - 91 = 5261
  
  console.log(`💰 [BILLING-${endpoint}] Deduction: ${currentBalance} - ${pointsToDeduct} = ${newBalance}`);
    ↓

步骤 4.7: 更新数据库余额
────────────────────────────────────────────────────────

  const { error: updateError } = await supabaseClient
    .from('users')
    .update({ balance: newBalance })
    .eq('id', userId);
  
  // SQL 等价于：
  // UPDATE users SET balance = 5261 WHERE id = '9dee4891-89a6-44ee-8fe8-69097846e97d'
  
  if (updateError) {
    console.error(`❌ [BILLING-${endpoint}] Failed to deduct points: ${updateError.message}`);
    return {
      tokens: totalTokens,
      points: pointsToDeduct,
      newBalance: currentBalance,  // 失败时返回原余额
      success: false
    };
  }
  
  console.log(`✅ [BILLING-${endpoint}] Deducted ${pointsToDeduct} points. Balance: ${currentBalance} → ${newBalance}`);
    ↓

步骤 4.8: 记录使用历史（可选）
────────────────────────────────────────────────────────

  // 可以记录到 token_usage 表
  await supabaseClient
    .from('token_usage')
    .insert({
      user_id: userId,
      tokens_used: totalTokens,
      points_used: pointsToDeduct,
      model_name: 'dify-workflow',
      conversation_id: conversationId,
      message_id: messageId,
      created_at: new Date().toISOString()
    });
    ↓

步骤 4.9: 返回计费信息
────────────────────────────────────────────────────────

  return {
    tokens: totalTokens,          // 4163
    points: pointsToDeduct,       // 91
    cost: actualCost.toFixed(6),  // "0.009055"
    newBalance: newBalance,       // 5261
    success: true,
    isGuest: false
  };
}
    ↓
    ↓ 返回到主流程
    ↓

第5步: 发送余额更新事件给前端
────────────────────────────────────────────────────────
📍 位置: server.js:1886-1898

// billingInfo = { tokens: 4163, points: 91, newBalance: 5261, success: true }

if (billingInfo && billingInfo.newBalance !== null && billingInfo.success) {
  console.log(`🔥 [STREAM] Sending balance update to frontend: ${billingInfo.newBalance}`);
  
  // 通过 SSE 流发送特殊事件给前端
  res.write(`data: ${JSON.stringify({
    event: 'balance_updated',  // ← 特殊事件类型
    data: {
      newBalance: billingInfo.newBalance,      // 5261
      pointsDeducted: billingInfo.points,      // 91
      tokens: billingInfo.tokens,              // 4163
      cost: billingInfo.cost                   // "0.009055"
    }
  })}\n\n`);
}
    ↓

第6步: 保存对话历史到数据库
────────────────────────────────────────────────────────
📍 位置: server.js:1900-1906

const conversationCreated = await ensureConversationExists(
  supabase, 
  conversationId, 
  finalData.conversation_id, 
  userId
);

if (conversationCreated !== false) {
  await saveMessages(supabase, conversationId, message, finalData);
  console.log('✅ Saved streaming conversation to database');
}
    ↓

第7步: 结束流响应
────────────────────────────────────────────────────────

res.write('data: [DONE]\n\n');
res.end();
    ↓

═══════════════════════════════════════════════════════════════
【前端接收和处理】
═══════════════════════════════════════════════════════════════
📍 位置: src/components/chat/DifyChatInterface.tsx:1857-1905

前端监听 SSE 流：

const eventSource = new EventSource('/api/dify/chat-messages');

eventSource.onmessage = (event) => {
  const parsed = JSON.parse(event.data);
  
  // 普通消息块
  if (parsed.event === 'message') {
    appendToChat(parsed.answer);
  }
  
  // 🎯 余额更新事件
  if (parsed.event === 'balance_updated') {
    console.log('🔥 [Frontend] Received balance_updated:', parsed.data);
    
    // 更新 authService 内存
    const currentUser = authService.getCurrentUserSync();
    if (currentUser) {
      currentUser.balance = parsed.data.newBalance;  // 5261
    }
    
    // 更新 localStorage
    localStorage.setItem('currentUser', JSON.stringify(currentUser));
    
    // 触发全局事件，通知所有组件
    window.dispatchEvent(new CustomEvent('balance-updated', {
      detail: { 
        balance: parsed.data.newBalance,      // 5261
        pointsDeducted: parsed.data.pointsDeducted,  // 91
        tokens: parsed.data.tokens            // 4163
      }
    }));
    
    // 显示 Toast 通知
    toast.success(`✅ 消费 ${parsed.data.tokens} tokens (${parsed.data.pointsDeducted} 积分)`, {
      description: `余额: ${parsed.data.newBalance} 积分`
    });
  }
};
    ↓

═══════════════════════════════════════════════════════════════
【UI 组件更新】
═══════════════════════════════════════════════════════════════

PointsDisplay 组件监听 'balance-updated' 事件：

useEffect(() => {
  const handleBalanceUpdate = (event: CustomEvent) => {
    const newBalance = event.detail.balance;  // 5261
    
    setUser(prev => ({ 
      ...prev, 
      balance: newBalance 
    }));
    
    // 添加到历史记录
    setPointsHistory(prev => [{
      change: -event.detail.pointsDeducted,  // -91
      timestamp: new Date().toISOString()
    }, ...prev]);
  };
  
  window.addEventListener('balance-updated', handleBalanceUpdate);
  
  return () => {
    window.removeEventListener('balance-updated', handleBalanceUpdate);
  };
}, []);
    ↓

界面显示更新：
┌─────────────────────────────────────┐
│  💰 5261 积分                       │  ← 实时更新
│  ≈ $0.5261                         │
│                                     │
│  最近使用:                          │
│  • 刚刚: -91 积分                   │
└─────────────────────────────────────┘
```

---

## 🔑 关键技术点

### 1️⃣ SSE (Server-Sent Events) 流式通信

```javascript
// 后端设置 SSE 响应头
res.setHeader('Content-Type', 'text/event-stream');
res.setHeader('Cache-Control', 'no-cache');
res.setHeader('Connection', 'keep-alive');

// 发送数据
res.write(`data: ${JSON.stringify({ event: 'message', answer: '...' })}\n\n`);

// 前端接收
const eventSource = new EventSource('/api/dify/chat-messages');
eventSource.onmessage = (event) => {
  const parsed = JSON.parse(event.data);
  // 处理数据
};
```

### 2️⃣ Dify API Usage 数据结构

```json
{
  "metadata": {
    "usage": {
      "prompt_tokens": 3500,
      "completion_tokens": 663,
      "total_tokens": 4163,
      "prompt_price": "0.00350",
      "completion_price": "0.00555",
      "total_price": "0.00905475",
      "currency": "USD",
      "latency": 2.5
    }
  }
}
```

### 3️⃣ 积分计算公式

```javascript
// 美元 → 积分转换率: 1 USD = 10000 积分
const pointsToDeduct = Math.ceil(actualCost * 10000);

// 示例：
// $0.00905475 × 10000 = 90.5475 → Math.ceil() → 91 积分
```

### 4️⃣ 数据库操作（Supabase）

```javascript
// 查询余额
const { data } = await supabase
  .from('users')
  .select('balance')
  .eq('id', userId)
  .single();

// 更新余额
await supabase
  .from('users')
  .update({ balance: newBalance })
  .eq('id', userId);
```

### 5️⃣ 游客用户处理

```javascript
// 如果用户不在数据库中
if (balanceError) {
  // 在内存中记录游客余额（服务器重启会丢失）
  global.guestBalances = new Map();
  global.guestBalances.set(userId, 10000 - pointsToDeduct);
  
  return {
    isGuest: true,
    newBalance: 10000 - pointsToDeduct
  };
}
```

---

## 📊 数据流动图

```
┌─────────────┐
│   前端      │
│ (浏览器)    │
└──────┬──────┘
       │
       │ HTTP POST /api/dify/chat-messages
       │ { message, userId, conversationId }
       │
       ↓
┌─────────────┐
│   后端      │
│ (server.js) │
└──────┬──────┘
       │
       │ HTTP POST https://api.dify.ai/v1/chat-messages
       │ { query, user, response_mode: 'streaming' }
       │
       ↓
┌─────────────┐
│  Dify API   │
│ (外部服务)  │
└──────┬──────┘
       │
       │ SSE Stream
       │ ├─ data: {"event": "message", "answer": "..."}
       │ ├─ data: {"event": "message", "answer": "..."}
       │ └─ data: {"event": "message_end", "metadata": {"usage": {...}}}
       │
       ↓
┌─────────────────────────────────┐
│   后端 handleTokenBilling()     │
│                                 │
│  1. 提取 usage.total_tokens     │
│  2. 计算积分: cost × 10000      │
│  3. 查询数据库当前余额          │
│  4. 计算新余额: old - points    │
│  5. UPDATE users SET balance    │
│  6. 返回 billingInfo            │
└────────┬────────────────────────┘
         │
         │ billingInfo = { newBalance: 5261, points: 91, tokens: 4163 }
         │
         ↓
┌─────────────────────────────────┐
│   后端发送 SSE 事件              │
│                                 │
│  res.write(`data: {             │
│    "event": "balance_updated",  │
│    "data": {                    │
│      "newBalance": 5261,        │
│      "pointsDeducted": 91       │
│    }                            │
│  }\n\n`)                        │
└────────┬────────────────────────┘
         │
         │ SSE Stream
         │
         ↓
┌─────────────────────────────────┐
│   前端监听 balance_updated       │
│                                 │
│  1. 更新 authService.balance    │
│  2. 更新 localStorage           │
│  3. 触发 balance-updated 事件   │
│  4. 显示 Toast 通知             │
└────────┬────────────────────────┘
         │
         │ CustomEvent('balance-updated')
         │
         ↓
┌─────────────────────────────────┐
│   UI 组件更新                   │
│                                 │
│  PointsDisplay: 5352 → 5261     │
│  Navbar: 更新余额显示           │
│  Toast: "消费 91 积分"          │
└─────────────────────────────────┘
```

---

## 🛡️ 错误处理机制

### 1. Token 数据缺失
```javascript
if (!totalTokens || totalTokens === 0) {
  console.error('🚨 No token data found!');
  // 不扣除积分，记录错误
  return { tokens: 0, success: false };
}
```

### 2. 用户不存在
```javascript
if (balanceError) {
  console.log('⚠️ User not found in database');
  // 作为游客处理，在内存中记录
  return { isGuest: true, newBalance: 9909 };
}
```

### 3. 数据库更新失败
```javascript
if (updateError) {
  console.error('❌ Failed to update balance');
  // 返回原余额，标记失败
  return { success: false, newBalance: currentBalance };
}
```

### 4. 余额不足
```javascript
const newBalance = Math.max(0, currentBalance - pointsToDeduct);
// 使用 Math.max(0, ...) 确保余额不为负数
```

---

## 📝 日志输出示例

```bash
# 后端控制台输出：

🔍 [BILLING-WORKFLOW_STREAM] Checking responseData structure
✅ [BILLING-WORKFLOW_STREAM] Found usage in metadata.usage
💰 [BILLING-WORKFLOW_STREAM] Multi-node LLM: 4163 tokens
💰 [COST-WORKFLOW_STREAM] Actual cost: $0.009055 = 91 points
💰 [BILLING-WORKFLOW_STREAM] Deduction: 5352 - 91 = 5261
✅ [BILLING-WORKFLOW_STREAM] Deducted 91 points. Balance: 5352 → 5261
🔥 [STREAM] Sending balance update to frontend: 5261
✅ Saved streaming conversation to database
```

```bash
# 前端控制台输出：

🔥 [Frontend-Streaming] Received balance_updated from backend: {newBalance: 5261, pointsDeducted: 91, tokens: 4163}
✅ [Frontend-Stream] Updated authService balance: 5261
🎯 [Event] balance-updated event dispatched for streaming mode
✅ [PointsDisplay] Balance updated: {oldBalance: 5352, newBalance: 5261, difference: -91}
```

---

这就是完整的后端积分扣除流程！**后端完全负责计费，前端只负责接收更新和显示UI**。
